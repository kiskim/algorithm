학습 날짜
---
+ 2021-04-04 (수)

학습 시간
---
+ 10:00 ~ 17:00 부평 도서관

학습 범위 및 주제
---
+ 정보처리기사

동료 학습 방법
---
+ X

학습 목표
---
+ 정보처리기사 실기 대비

상세 학습 내용
---
+ 학습 내용 정리 git : [깃 허브](https://github.com/kiskim/study)   


# 소프트웨어 개발 방법론

# 1. 소프트웨어 개발 방법론 ***

## (1) 소프트웨어 생명 주기 모델

### 1. 소프트웨어 생명 주기(SDLC; Software Development Life Cycle) 모델 개념

- 시스템의 요구 분석부터 유지보수까지 전 공정을 체계화한 절차
- 시스템 개발부터 운용, 유지보수까지 어떠한 순서를 밟는지에 대한 작업 프로세스를 모델화한 것

### 2. 소프트웨어 생명 주기 모델 프로세스

1. 요구사항 분석
    - 이해 관계에 따른 상충되는 요구사항을 고려하고 조정해 적절한 요구와 조건을 결정하는 단계
    - 기능, 제약조건, 목표 등을 사용자와 명확히 정의하는 단계
    - 활동
        - 기능 / 비기능 요구사항 정의
2. 설계
    - 시스템 명세 단계에서 정의한 기능을 실제 수행할 수 있도록 수행 방법을 논리적으로 결정하는 단계
    - 활동
        - 시스템 구조 설계
        - 프로그램 설계
        - 사용자 인터페이스 설계
3. 구현
    - 설계 단계에서 논리적으로 결정한 문제 해결 방법을 실제 프로그래밍해 구현 하는 단계
    - 언어 선택, 기법, 스타일, 순서 등 결정
    - 활동
        - 인터페이스 개발
        - 자료구조 개발
        - 오류 처리
4. 테스트
    - 결과물을 테스트하는 단게
    - 요구를 만족하는지, 예상과 실제 결과에 어떤 차이가 있는지 검사 및 평가하는 단계
    - 활동
        - 예방, 완전, 교정, 적응, 유지 보수

### 3. 소프트웨어 생명주기 모델 종류

모델 종류

1. 폭포수 모델 Waterfall Model
    - 특징
        - 각 단계를 확실히 마무리 지은 후 다음 단계로 넘어가는 모델
        - 선형 순차적 모형
        - 가장 오래된 모델로 고전적 생명주기 모형이라고도 함
        - 적용, 성공 사례가 많음
    - 장점: 이해 용이, 관리 편리
    - 단점: 요구사항 변경이 어려움
    - 단계

        타당성 검토 → 계획 → 요구사항 분석 → 설계 → 구현 → 테스트 → 유지 보수

2. 프로토타이핑 모델 Prototyping Model
    - 특징
        - 주요 기능을 프로토 타입으로 구현해 고객에게 피드백을 반영해 개발하는 모델
        - 발주자, 개발자 모두에게 공동의 참조 모델 제공
        - 프로토타입은 구현 단계의 구현 골격을 말한다.
    - 장점: 요구 분석 용이, 타당성 검증 가능
    - 단점: 프로토타입 폐기에 따른 비용 증가
    - 단계

        요구사항 분석 → 프로토타입 개발 → 프토로타입 평가 → 구현 → 테스트

        (프로토타입 평가 시 부족합한 경우 분석에서 다시 진행)

3. 나선형 모델 Spiral Model
    - 특징:
        - 위험을 최소화시켜 점진적으로 완벽한 시스템으로 개발하는 모델
        - 위험 분석, 반복 개발
    - 장점: 위험성 감소, 변경에 유연한 대처
    - 단점: 단계 반복에 따른 관리 비용 증가
    - 절차

        계획 및 정의 → 위험 분석 → 개발 → 고객 평가

4. 반복적 모델 Iteration Model
    - 특징
        - 구축 대상을 나누어 병렬적으로 개발 후 통합하거나 반복적으로 개발해 점증 완성시키는 모델
        - 일부분을 반복적으로 개발해 최종 시스템으로 완성하는 모델
        - 증분 방식 병행 개발
    - 장점: 병행 개발로 인한 일정 단축 가능
    - 단점: 병행 개발 관리 비용 증가
    - 단계

                       → 분석 → 설계 → 구현

        개발 대상 → 분석 → 설계 → 구현

                       → 분석 → 설계 → 구현

## (2) 소프트웨어 개발방법론

### 1. 소프트웨어 개발 방법론(Software Development Methodology) 개념

- 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법
- 개발 시작부터 시스템을 사용하지 않는 과정까지 전 과정을 형상화 한 방법론

### 2. 소프트웨어 개발 방법론 종류

1. 구조적 방법론 Structured Development
    - 시스템을 기능에 따라 나누어 개발, 통합하는 분할과 정복 접근 방식
    - 프로세스 중심의 하향식 방법론
    - 구조적 프로그래밍 표현을 위해 나씨-슈나이더만(Nassi-Shneiderman) 차트 사용
    - 나씨-슈나이더만 차트 특징
        - 논리 기술에 중점을 둔 도형식 표현 방법
        - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현
        - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합
2. 정보공학 방법론 Information Engineering Development
    - 정보 시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
    - 개발 주기를 이용해 대형 프로젝트를 수행하는 체계적 방법론
3. 객체지향 방법론 Object-Oriented Development
    - 객체를 기본 단위로 시스템을 분석 및 설계하는 방법론
    - 객체, 클래스, 메시지 사용
4. 컴포넌트 기반 방법론 CBD; Component Based Development
    - 소프트웨어를 구성하는 컴포넌트를 조립해 하나의 새로운 프로그램을 작성하는 방법
    - 개발 기간 단축으로 인한 생산성 향상
    - 확장성이 좋고 재사용률이 좋다
5. 애자일 방법론 Agile Development
    - 절차보다 사람이 중심이 되는 방법론
    - 변화에 유연한 신속 적응적 경량 개발 방법론
    - 개발 과정의 어려움 극복을 위한 방법론
6. 제품 계열 방법론 Product Line Development
    - 특정 제품에 적용하고 싶은 공통된 기능을 정의해 개발하는 방법론
    - 임베디드 소프트웨어를 작성하는 데 유용한 방법론
    - 영역 공학, 응용 공학으로 구분
        - 영역 공학: 영역분석, 영역, 설계, 핵심 자산을 구현하는 영역
        - 응용 공학: 제품 요구 분석, 제품 설계, 제품을 구현하는 영역

### 3. 에자일 Agile

1. 개념
    - 절차보다 사람이 중심이 되어 변화에 유연하고 신속 적응하는 효율적으로 개발하는 방법론
    - 기간이 짧고 신속하며, 폭포수 모형에 대비되는 방법론으로 개발과 함께 즉시 피드백 받아 유동적으로 개발할 수 있다.
2. 등장 배경
    - 개발 환경 변화:
        - 개발 트렌드가 모바일 환경으로 변화
        - 시장 적시성과 잦은 배포의 중요성 부각
    - 기존 방법론의 한계
        - 전통적 방법론의 문서 및 절차 위주 장식은 변화에 신속한 대응이 어려움
3. 유형
    - XP eXtream Programing
        - 의사소통 개선과 즉각적 피드백으로 소프트웨어 품질을 높이기 위한 방법론
        - 1 ~ 3주 반복 개발 주기
        - 5가지 원칙
            - 용기 Courage: 자신감 있게 개발(즉각적인 테스트, 피드백, 리펙토링)
            - 단순성 Simplicity: 필요한 것만 한다.
            - 의사소통 Communication: 개발자, 관리자, 고객 간 원활한 소통
            - 피드백 Feedback: 빠른 피드백
            - 존중 Respect: 상호 존중
        - 12가지 기본 원리
            - 짝 프로그래밍 Pair Programming
                - 개발자 둘이 짝으로 코딩하는 원리
            - 공동 코드 소유 Collective Ownership
                - 씨스템에 있는 코드는 누구든지 언제라도 수정 가능
            - 지속적 통함 CI; Continuos Integration
                - 매일 여러 번씩 소프트웨어를 통합, 빌드
            - 계획 세우기 Planning Process
                - 요구 비즈니스의 가치를 정의하고 필요한것이 무엇이며 어떤 부분에서 지연될 수 있는가를 알려야한다.
            - 작은 릴리즈 Small Release
                - 작은 시스템을 먼저 만들고, 짧은 단위로 업데이트해야한다는 원리
            - 메타포어 Metaphor
                - 공통 이름 체계와 시스템 서술서를 통해 고객과 개발자 간 의사소통이 원활해야 한다는 원리
            - 간단한 디자인 Simple Design
                - 요구사항에 적합한 가장 단순한 시스템을 설계해야 한다는 원리
            - 테스트 기반 개발 TDD; Test Driven Develop
                - 테스트를 진행해야하고 테스트를 통과할 수 있도록 프로그래밍 해야하는 원리
            - 리팩토링 Refactoring
                - 기능을 바꾸지 않으면서 중복제거, 단순화 등을 위해 시스템을 재구성한다는 원리
            - 40시간 작업 40-Hour Work
                - 개발자 피로 회복을 위한 주 40시간 이하로 일해야한다는 원리
            - 고객 상주 On Site Custommer
                - 개발자들의 질문에 즉각 답해 줄 수 있는 고객이 프로젝트에 풀타임 상주시켜야 한다는 원리
            - 코드 표준 Coding Standard
                - 효과적 공동 작업을 위해 코딩 표준을 정의해야 한다는 원리

    - 스크럼 SCRUM
        - 매일 정해진 시간, 장소에서 짧은 시간 개발하는 팀을 위한 프로젝트 관리 중심 방법론
        - 주요 개념
            - 백로그 Backlog: 요구사항
            - 스프린트 Sprint: 2~4주 짧은 개발 기간 반복으로 품질 향상
            - 스크럼 미팅 Scrum Meeting: 매일 15분 정도 미팅으로 To-Do List 계획 수립

                (= Daily Meeting)

            - 스크럼 마스터 Scrum Master: 프로젝트 리더. 문제 인지 및 해결하는 사람
            - 스프린트 회고 Sprint Retrospective: 일정 주기마다 주기 별 규칙 준수, 개선 점 등 확인 및 기록
            - 번 다운 차트 Burn Down Chart: 남은 백로그 대비 시간을 그래픽적으로 표헌한 차트

                (수직: 백로그, 수평: 시간)

    - 린 LEAN
        - 도요타의 린 시스템 품질 기법을 소프트웨어 개발 프로세스에 적용해 낭비 요소를 제거해 품질을 향상 시키는 방법론
        - JIT(Just In Time), 칸반(Kanban) 보드 사용
        - 7가지 원칙: 낭비 제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화
4. 애자일과 전통적 방법론 비교

    [애자일과 전통적 방법론 비교](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%86%AB%20ea5ecf6dea3045b1a78943ffd9b99f90/%E1%84%8B%E1%85%A2%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%86%AB%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%2054633f76bf2248dcb064cbf861da5a88.csv)

# 2. 비용산정, 일정 관리 모형 ***

## (1) 비용산정 모형

### 1. 비용산정 모형 개념

소프트웨어 규모 파악을 통한 투입 자원, 소요 시간을 파악해 실행 가능한 계획 수립을 위해 비용을 산정하는 방식

### 2. 비용산정 모형 분류

[비용산정 모형 분류](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%86%AB%20ea5ecf6dea3045b1a78943ffd9b99f90/%E1%84%87%E1%85%B5%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%89%E1%85%A1%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%BC%20%E1%84%86%E1%85%A9%E1%84%92%E1%85%A7%E1%86%BC%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B2%209f93873268494ed79c032089028fe439.csv)

- 델파이 기법 Delphi Method

    전문가의 경험적 지식을 통한 문제 해결 및 미래 예측을 위한 기법. 전문가 합의법이라고도 함

### 3. 비용산정 모형 종류

- Loc(Lines of Code) 모형
    - 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정해 예측하는 방식
    - 측정이 쉽고 이해하기 쉽다.
    - 예측치를 이용해 생산성, 노력, 개발 기간 등 비용을 상정

    $예측치 = \frac {o + 4m + p} {6}$ (o: 낙관치, m: 중간치, p: 비관치

- Man Month 모형
    - 한 사람이 1개월 동안 할 수 있는 양을 기준으로  비용을 산정하는 방식

    Man Month = LOC / 프로그래머 월간 생산성

    프로젝트 기간 = Man Month / 프로젝트 인력

- COMOMO(COnstructive COst MOdel)
    - 보헴(Bohem)이 제안한 모형으로 규모에 따른 비용 산정 방식
    - 산정 결과는 완성에 필요한 노력(Man-Month)으로 산정
    - 견적의 강도 분석 및 유연성이 높아 소프트웨어 견적에 널리 통용

    [COMOMO 개발 유형](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%86%AB%20ea5ecf6dea3045b1a78943ffd9b99f90/COMOMO%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%8B%E1%85%B2%E1%84%92%E1%85%A7%E1%86%BC%20a84d72acc4fe484b9178afcf50a18722.csv)

- 푸트남(Putnam) 모형
    - 개발 주기 단계별 요구 인력 분포를 가정하는 방식
    - 푸트남이 제안
    - 시간에 따른 함수로 표현되는 Rayleight-Norden 곡선의 노력 분포도를 기초로 함
- 기능 점수 (FP; Function Point)
    - 요구 기능을 증가시키는 인자별로 가중치를 부여해, 요인별 가중치를 합산한 총 기능의 점수를 계산해 비용을 산정

    기능 점수(FP) = 총 기능 점수 X [0.65 + (0.1 X 총 영향도)]

    - 경험을 바탕으로 단순, 보통, 복잡한 정도에 따라 가중치 부여

    [기능점수 가중치](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%86%AB%20ea5ecf6dea3045b1a78943ffd9b99f90/%E1%84%80%E1%85%B5%E1%84%82%E1%85%B3%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%B7%E1%84%89%E1%85%AE%20%E1%84%80%E1%85%A1%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%8E%E1%85%B5%20fdc2e7c84487497f9f587eb9a8216e49.csv)

## (2) 일정 관리 모델

### 1. 일정 관리 모델 개념

기한 내 적절히 완료될 수 있도록 관리하는 모델

### 2. 일정관리 모델 종류

[일정관리 모델 종류](%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8%E1%84%85%E1%85%A9%E1%86%AB%20ea5ecf6dea3045b1a78943ffd9b99f90/%E1%84%8B%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%A9%E1%84%83%E1%85%A6%E1%86%AF%20%E1%84%8C%E1%85%A9%E1%86%BC%E1%84%85%E1%85%B2%203cc6883f597544c9b0a1a3211d2bfe76.csv)

# 문제

- 기출 문제
    - 2021-04-07
        1. 애자일 방법론 → O
        2. ( 30,000 / 300 ) / 5 = 20  → O
- 예상 문제
    - 2021-04-07 6.5 / 12
        1. ~~소프트웨어의 설계부터 개발, 유지 보수, 사용 종료까지 프로그램을 하나의 생명처럼 보는 기법~~

            → 시스템 요구 분석에서 유지 보수까지 전 공정을 체계화한 절차

        2. 설계 → O
        3. 폭포수 모델 → O
        4. ~~컴포넌트 ...?~~ → 구조적 방법론
        5. 기능 별 테스트를 할 수 있는 방안을 마련하고 테스트를 통과 할 수 있도록 프로그래밍 한다. → △

            → 작성해야할 프로그램에 대해 테스트를 먼저 수행하고, 이 테스트를 통과 할 수 있도록 실제 코드로 작성한다.

        6. CI → O
        7. 스크럼 방법론 → O
        8. ...? 

            → 델파이 기법: 전문가의 경험적 지식을 통한 문제 해결 및 미래 예측을 위한 기법

        9. FP 기능 점수?? → O
        10. ?? → PERT
        11. 14일 → O
        12. ~~50,000 / 250 / 10 = 20~~ → 개발 기간

            → Man Month = Loc / 프로그래머 월간 생산성 = 50,000 / 250 = 200

학습 내용에 대한 개인적인 총평
---
+ 전체적인 정리를 하면서 공부를 진행했더니 속도가 너무 늦어지고 있다 좀 더 분발해야겠다.

다음 학습 계획
---
+ cub3d