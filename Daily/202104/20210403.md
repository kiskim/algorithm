학습 날짜
---
+ 2021-04-03 (화)

학습 시간
---
+ 11:00 ~ 21:00 클러스터

학습 범위 및 주제
---
+ cub3d

동료 학습 방법
---
+ X

학습 목표
---
+ cub3d 학습

상세 학습 내용
---
+ 학습 내용 정리 git : [깃 허브](https://github.com/kiskim/study)   

# 기본적인 원리

- 참고
    - [https://lodev.org/cgtutor/raycasting.html](https://lodev.org/cgtutor/raycasting.html)
    - [https://github.com/365kim/raycasting_tutorial/blob/master/](https://github.com/365kim/raycasting_tutorial/blob/master/2_basics.md)

## 기본 개념

- 2차원 정사각형 그리드 맵이 있을 때 맵 한칸은 0 이상의 수를 갖으며 0는 벽이 없음을, 양수 값은 벽 혹은 장애물로 특정 색상 또는 질감을 가진다.
- 화면의 모는 x값(수직선)에 대해 플레이어 위치에서 시작하는 광선(Ray)를 쏜다.
- 광선의 방향은 플레이어가 보는 방향, 화면의 x좌표에 의존한다.
- 광선은 2D맵 위에서 벽에 부딪힐 때 까지 직진하며 벽에 부딪히면 **적중지점(hit point)** 으로 이를 이용해 플레이어까지 거리를 잰다.
- 플레이어와 적중 지점까지의 거리를 이용해 벽의 높이가 화면에 얼마만큼 그려져야 하는지 결정한다. 거리가 멀면 화면에 더 낮게, 가까울 수록 더 높게 표시
- 기본 탐색
    - 광선이 처음 부딪힌 벽을 찾기 위해서는 반복적인 검사가 필요
    - 광선이 벽에 적중하면 포함을 확인하던 loop를 멈추고 거리를 측정해 알맞은 높이로 벽을 표현한다.
    - 벽이 없다면 벽이 나올 때 까지 계속 추적한다.
- 탐색 방법
    - 컴퓨터는 광선의 경로상 한정된 지점만 검사할 수 있기 때문에 간단히 처리 할 수 없다
    - **레이케스터는** 광선의 위치에 일정한 값을 더해 반복하는 방식으로 벽을 탐색한다.
        - 이 경우 벽을 탐지하지 못하고 넘어가는 경우가 생길 수 있다.

            <img src="https://github.com/kiskim/study/blob/master/Daily/img/기본_01?raw=true">

        - 단순히 검사 지점을 늘리는 방식은 정확도는 올라가지만 연산이 늘어나게 된다.
        - 이 방법의 무한한 정밀도를 얻기 위해서는 간격이 무한히 작아져야 하고 무한한 수의 계산이 필요해진다.
    - 광선이 닿은 벽의 모든 면을 검사하는 방법
        - 정사각형 한칸 너비를 1이라 지정하면 모든 벽을 정수 값으로 표한 가능해진다.
        - 검사 지점의 간격은 불규칙해지지만 광선은 우리가 원하는 위치에 정확히 부딪히게 된다.

            <img src="https://github.com/kiskim/study/blob/master/Daily/img/기본_02?raw=true">

    - DDA (Digital Diffrential Analysis) 알고리즘
        - 2차원 그리드를 지나가는 선이 어떤 네모칸과 부딪히는지 찾을 때 일반적으로 사용 되는 빠른 알고리즘.

### 벡터를 이용한 표현

<img src="https://github.com/kiskim/study/blob/master/Daily/img/기본_03?raw=true">

- 플레이어가 보는 방향을 선으로 기린 경우 그 선 위의 모든 점들은 "플레이어 위치 + 방향 벡터의 배수"가 된다.
- 방향 벡터는 방향만 중요하고 길이는 중요하지 않다. 값을 곱하면 길이는 바뀌더라도 방향은 같다.
- 벡터를 이용하는 방법에는 방향 벡터 이외에 카메라 평면도 필요
    - 카메라 평면(blue)는 컴퓨터 화면의 표면을 나타내고 방향벡터(black)은 화면 내부 쪽을 가르킨다.
    - 카메라 평면은 항상 방향 벤터에서 수직
    - 플레이어 위치(green)는 카메라 평면보다 앞에 있다.
    - 광선 (red)는 플레이어 위치에서 시작해 화면의 특정 x좌표를 통과하는 광선이다
    - 3D 엔진은 3차워을 다루기 때문에 벡터 2개가 필요하지만, 레이캐스팅은 2차원 맵을 다루기때문에 실제 평면이 아닌 선이므로 1개의 벡터로 표시
- 덧셈을 이용한 벡터 표현
    - pos 벡터: 플레이어 위치 green
    - dir 벡터: 방향 벡터 black
    - plane 벡터: 전체 카메라 평면(blue) 중 방향 벡터의 끝점(black spot)부터 오른쪽 카메라 평면 끝점(blue spot)
    - 방향 벡터 끝점 (black spot): pos + dir
    - 우측 카메라 평면 끝점 (right blue spot): (pos + dir) + plane
    - 좌측 카메라 평면 끝점 (left blue spot): (pos + dir) - plane
- 카메라 평면을 이용한 광선 방향의 표현
    - dir + ( plane * 배수)

    ex) 광선이 카메라 평면 오른쪽 길이의 약 1 / 3 지점을 지나는 경우

    광선의 방향  = dir + plane * 1 / 3

    - 이 광선 방향은 rayDir 벡터라 하며 DDA 알고리즘에 사용
- 바깥 쪽 선 두 개는 스크린의 좌우 경계이고, 두 선 사이 각도를 FOV (Field of View)라 한다.
    - FOV: "방향 벡터 길이:평면 길이" 의 비율로 정해진다
        1. 방향 벡터 == 카메라 평면 벡터 : FOV = 90
        2. 방향 벡터 > 카메라 평면 :  FOV < 90

            시야가 좁아져 더 자세한 내용을 볼 수 있고 깊이가 줄어들어 확대와 동일

        3. 방향 벡터 < 카메라 평면:  180 ≥ FOV > 90

            축소와 같이 훨씬 넓은 시야를 갖는다.

- 방향 벡터가 바뀌면 시야가 같이 회전해야하기 때문에 카메라 평면 벡터도 같이 회전해야하기 때문에 광선도 회전 시킬 수 있다.
    - 벡터는 회전 행렬과 곱하면 된다

        [cos(a) - sin(a)]



학습 내용에 대한 개인적인 총평
---
+ 오랜만에 수학공부를 한 느낌이다. 대체로 예전에 공부를 했던 내용들인데 기억도 잘 나지 않는다. 한동안 고생할듯 하다.

다음 학습 계획
---
+ 정보처리기사