+ get_next_line_utils
    + ft_strlen
        + 문자열 길이를 반환하는 함수
    + ft_strdup
        + 입력받은 문자열을 새로운 메모리를 할당하고 값을 복사한 포인터를 반환하는 함수
    + ft_strjoin
        + 입력받은 두 문자열을 이어 붙인 값을 새로운 메모리 공각에 할당해 포인터를 반환하는 함수
        + libft와 다른 점으로 gnl에서 사용되는 경우는 첫 인자로 backup, 두 번째 인자로 buf를 입력 받는데 join의 결과가 backup으로 들어가야하기 때문에 이후에 사용하지 않아 메모리 해제(free)해준다.
    + ft_strchr
        + 입력받은 문자열에서 함께 입력 받은 문자의 위치 포인터를 반환하는 함수
        + 일치하는 함수가 없는 경우 NULL(0)을 반환한다

+ get_next_line
    + get_next_line
        + 과제의 메인 함수
        + 입력받은 파일 디스크럽터(fd: file discriptor)에서 문자열을 읽는 함수
        + 컴파일 시 정해진 BUFFER_SIZE 크기에 상관 없이 개행 문자(\n)가 나올 때 까지 읽은 후 반환하는 함수
        + 출력 값
            + 파일 읽기 성공
                +  1 - 읽기 성공, 아직 읽을 내용 남음
                +  0 - 파일 끝까지 다 읽음
                + -1 - 파일 읽기 중 에러 발생
        + 알고리즘
            1. 예외 처리
                + 버퍼 사이즈 0이하, 결과를 반환한 포인터가 없는 경우, fd가 음수인 경우, buf 동적 할당 에러 등 발생시 -1 반환
            2. backup[fd] - 입력 받은 fd에 해당하는 문자열이 비어있는 경우 빈 문자열을 할당해 준다.
            3. 반복 문 수행
                + 조건 1: 개행 문자가 존재 하지 않는다
                + 조건 2: 읽은 문자열의 수가 존재한다.
                1. 파일에서 읽어온 데이터 buf의 데이터 끝에 널 문자를 입력해 끝 처리를 해준다
                2. backup에 buf를 이어 붙여주고, 기존 backup은 join 함수 내에서 free해준다.
            4. 메모리 해제
                + 사용이 끝난 buf를 free
                + 파일 읽기에 에러가 발생 했을 시 backup의 길이가 1보다 작은 경우 free
            5. 결과 도출 함수(get_result) 결과를 바로 반환
    + get_result
        + get_next_line에서 얻은 결과를 이용해 최종 결과를 반환하는 함수
        + 현재 작업 중인 backup의 개행 문자 존재 여부에 따른 분기 작업을 진행
        + 알고리즘
            + 개행 문자의 포인터가 0(NULL)이 아닌 경우
                1. 개행문자의 포인터의 값을 \n -> \0으로 변경
                2. ft_strdup를 이용해 원래 개행문자였던 곳 앞까지 복제 할 당해 +line에 입력
                3. 원래 개행문자였던 곳 이후부터 값을 새로 할당해 복제
                4. 현재 작업중인 backup의 메모리 free
                5. 3의 결과를 backup에 다시 저장
                6. 개행 문자가 존재해서 결과를 출력했기 때문에 반환 값을 1
            + 개행 문자의 포인터가 0인 경우
                1. 현재 작업중인 backup의 모든 내용을 복제 할당해 *line에 입력
                2. backup의 메모리를 free 후 0으로 초기화
                3. 개행 문자 없이 결과 함수에 다다렀기 때문에 읽을 것이 남아있지 않아 0을 반환