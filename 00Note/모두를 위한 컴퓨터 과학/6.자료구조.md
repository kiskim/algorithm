배열 메모리 할당
===
+ C에서 배열의 크기가 할당된 경우 크기가 고정 되며 해당 배열의 마지막 메모리 다음에는 다른 곳에서 사용중인지 비어있는지 알 수 없기 때문에 배열의 크기 자체를 늘릴 수는 없다
+ 때문에 배열의 크기를 늘리기 위해서는 새로운 메모리를 할당해 데이터를 복사하는 방법을 사용해야한다.
+ 함수로는 realloc을 사용할 수 있다
	```
	relloc('변수명', sizeof(자료형) * 크기);
	```
<br><br>

자료 구조
===
+ 자료 구조는 메모리를 효율적으로 관리하기 위해 정의하는 구조체이다.

연결 리스트 - Linked list
---
+ 배열은 인덱스의 값이 메모리 상에 연이어 저장되어 있어 길이 변경이 필요한 경우 매우 비효율적인 구조
+ 배열의 단점을 보완하기 위한 자료구조가 연결 리스트이다
+ 연결 리스트는 데이터와 다음 노드의 주소 값을 저장하는 방식
+ 마지막 노드에는 다음 주소 값이 없기 때문이 '\0' 널문자가 저장되어 끝을 확인 할 수 있다.
+ 겁색 시간 O(n)

트리 구조
---
+ 트리: 연결 리스트를 기반으로 한 데이터 구조
+ 각 노드는 일정한 층에 속하고, 다음 층의 노드들을 가리키는 포인터를 가진다.
+ 아래와 같은 나무를 뒤집은거 같은 형태를 가지며 가장 높은 층의 트리 시작 지접을 루트라고 하며, 다음 층의 노드들을 가리키고 있는데 이를 자식 노드라고 한다.

	<img src="../img/binary_search_tree.png"></img>

+ 위 그림은 구체적으로 '이진 검색 트리'라고 한다.
	+ 하나의 노드는 두개의 자식 노드를 가진다.
	+ 두 자식 노드는 왼쪽에는 자신보다 작은, 오른쪽에는 큰 자식 노드를 가진다.
	+ 검색 실행 시간, 노드 삽입 시간 모두 O(log n)

해시 테이블
---
+ 해시 테이블 == 연결 리스트의 배열
+ 여러 값들이 '해시 함수'라는 맞춤형 함수에 의해 분류
+ 분류된 값들은 연결 리스트로 이어진다.
+ 해시 함수가 '이름의 가장 첫 글자'인 경우

	<img src="../img/hash_table.png"></img>

+ 해시 함수가 이상적인 경우 바구니에 하나의 값만 들어가 O(1)이 된다
+ 최악의 경우 단 하나의 바구니에 담기는 경우 O(n)이 된다.
+ 일반적으로 최대한 많은 바구니를 만드는 해시 함수를 사용해 거의 O(1)에 가깝게 설계한다.

트라이
---
+ 문자열의 길이가 일정한 경우 관리에 최적의 자료 구조
+ 트라이 == 트리 형태의 자료 구조
+ 각 노드가 배열로 이루어진다
+ 알파벳으로 이루어진 문자열 값을 저장하는 경우
	+ 각 노드는 a ~ z까지 값을 가지는 배열
	+ 루트 노드를 시작으로 알파벳을 따라가면서 노드를 이어간다.
	
	<img src="../img/trie.png"></img>

+ 검색 시간은 '문자열의 길이'에 한정
+ 일반적인 영어 이름의 길이를 n이라 할 때, 검색 시간은 O(n)이지만 대부분의 이름은 그리 크지 않은 상수값이기 때문에 O(1)에 가깝다.

큐
---
+ 값이 아래로 쌓이는 구조
+ 선입 선출 - FIFO 방식을 따름
+ 배열, 연결 리스트를 통해 구현 가능

스택
---
+ 값이 위로 쌓이는 구조
+ 후입 선출 - LIFO 방식을 따름
+ 배열, 연결 리스트로 구현 가능

딕셔너리
---
+ 키-값으로 이루어짐
+ 키에 해당하는 값을 저장하고 읽어오는 것
+ 일반적인 의미에서 해시 테이블과 동일한 개념